<!DOCTYPE html> <html class=no-js lang=en> <head> <meta charset=utf-8> <meta content='width=device-width, initial-scale=1.0' name=viewport> <meta content='IE=edge,chrome=1' http-equiv=X-UA-Compatible> <title>Making WebDAV and NGINX Play Nice Together</title> <link href="/assets/stylesheets/app-afeada04.css" rel=stylesheet /> <script src="/assets/javascripts/modernizr-84a49412.js"></script> <link href='/assets/images/wb-square-e5e8663b.png' rel=icon sizes=128x128 type='image/png'> </head> <body class='blog blog_2009 blog_2009_03 blog_2009_03_20 blog_2009_03_20_webdav-nginx-play-nice blog_2009_03_20_webdav-nginx-play-nice_index f-topbar-fixed'> <div class='fixed raised'> <nav class=top-bar data-topbar role=navigation> <ul class=title-area> <li class=name> <h1> <a href='/'> <img alt=Agora class="wb-agora main-logo" src="/assets/images/wb-agora-b60168ae.svg"/> </a> </h1> </li> <li class='toggle-topbar menu-icon'> <a href='javascript:void(0)'> <span>Menu</span> </a> </li> </ul> <section class=top-bar-section> <ul class=right> <li> <a data-anchor href='/#about'>About</a> </li> <li> <a data-anchor href='/#team'>Team</a> </li> <li> <a href='/careers'>Careers</a> </li> <li> <a data-anchor href='/#contact'>Contact</a> </li> <li class=hydra-theme> <a href='http://hydra.agoragames.com'> <img alt=Hydra width=92 src="/assets/images/hydra-wordmark-6248cf07.svg"/> </a> </li> </ul> </section> </nav> </div> <div class=row> <div class=columns> <h1 class=blog-page-title> <a href="/blog">The <strong>Blog</strong> </a></h1> </div> </div> <div class=row> <div class='columns large-9'> <h2 class=blog__title> <a href="/blog/2009/03/20/webdav-nginx-play-nice/">Making WebDAV and NGINX Play Nice Together</a> </h2> <div class=blog__author> By <strong>Jason LaPorte</strong> </div> <div class=blog__date> Friday, March 20, 2009 </div> <div class=blog__body> <p>NGINX supports WebDAV, but its support is incomplete. Here&rsquo;s how we made a quick PHP hack to allow us to use WebDAV without having to proxy to another web server.</p> <p><a href="http://en.wikipedia.org/wiki/WebDAV">WebDAV</a> is a pretty awesome method of maintaining a shared data repository: it&rsquo;s simple, secure (or, at least, easily secured), and supported out of the box by just about everything across multiple platforms. The problem with it is that finding a decent WebDAV server is pretty hard: <a href="http://httpd.apache.org/">Apache</a> and <a href="http://www.lighttpd.net/">LightTPD</a> each provide WebDAV (to varying levels of support), but I had a very hard time finding other reputable-looking servers, and adding either of those two web servers into what is otherwise an <a href="http://nginx.net/">NGINX</a>-only web server architecture isn&rsquo;t very clean. (Personally, I hate maintaining Apache and LightTPD, as they are both CPU and memory hogs, Apache especially.)</p> <p>NGINX &ldquo;supports&rdquo; WebDAV by means of a module, but this support is incomplete: it only handles the WebDAV methods PUT, DELETE, MKCOL, COPY, and MOVE, and leaves the necessary OPTIONS and PROPFIND (and the optional LOCK, UNLOCK, and PROPPATCH) methods unimplemented. This basically translates to being able to read and write files on disk, but being unable to do an &ldquo;ls&rdquo; or &ldquo;dir&rdquo; to see what files are available. Obviously, this is insufficient, so I created some magic to allow us to use a WebDAV repository with a technology stack we already have in place (namely, NGINX and PHP FCGI).</p> <p>Looking around the internet for similar things, I find that <a href="http://notes.xiaoka.com/2008/04/13/git-repository-over-http-webdav-with-nginx/">we&rsquo;re not the only ones trying to do this,</a> and came across a <a href="http://plan9.aichi-u.ac.jp/netlib/webappls/webdav.cgi">Perl CGI script</a> that is/can be used in a similar fashion. Unfortunately, NGINX doesn&rsquo;t play very nice with CGI (as opposed to FCGI, which works great with it), and I felt like I needed some semblance of performance out of this script, so I wasn&rsquo;t going to fire up a Perl process for every request (which is how CGI works). Instead, I wrote up a similar script in PHP. (In case you&rsquo;re not familiar with how FCGI works, it instead runs a daemon, which simply returns a response to each given request without having to run new processes. This cuts out a lot of overhead and allows for much better performance.)</p> <p>The idea is this: we have NGINX put up it&rsquo;s WebDAV support, and for every method that NGINX doesn&rsquo;t know how to respond to, we proxy the request to a PHP script that can handle it on NGINX&rsquo;s behalf. Making a simple FCGI script in PHP is not especially complicated. The original skeleton of it looked like this:</p> <pre class="highlight php"><code><span class="cp">&lt;?php</span>

 <span class="nv">$request_method</span> <span class="o">=</span> <span class="nv">$ENV_</span><span class="p">[</span><span class="s1">'REQUEST_METHOD'</span><span class="p">]</span>

 <span class="k">switch</span> <span class="p">(</span><span class="nv">$request_method</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">case</span> <span class="s1">'PROPFIND'</span><span class="o">:</span>
 <span class="c1"># Code to handle PROPFIND goes here.
</span> <span class="k">break</span><span class="p">;</span>

 <span class="k">case</span> <span class="s1">'OPTIONS'</span><span class="o">:</span>
 <span class="c1"># Code to handle OPTIONS goes here.
</span> <span class="k">break</span><span class="p">;</span>

 <span class="k">default</span><span class="o">:</span>
 <span class="nb">header</span> <span class="p">(</span><span class="s1">'HTTP/1.1 400 Bad Request'</span><span class="p">);</span>
 <span class="k">break</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="cp">?&gt;</span>
</code></pre> <p>We are given the request method via an environment variable from NGINX. Depending on the method given, we have to handle it in its own special way. If we get a method we don&rsquo;t understand, we merely return an HTTP error. Simple!</p> <p>In fact, implementing the PROPFIND and OPTIONS methods wasn&rsquo;t especially difficult, aside from the fact that reading the <a href="http://www.ietf.org/rfc/rfc2518.txt">WebDAV RFC</a> is mind-numbingly tedious. (The OPTIONS method simply spits out a couple static headers, while PROPFIND returns an XML document of a directory listing. You can see my final implementation here. Be aware I didn&rsquo;t bother to fully support WebDAV: I merely implemented the simplest possible subset of the WebDAV functionality.)</p> <p>So, I hooked it up end to end. The NGINX configuration to do so looked something like this:</p> <pre class="highlight plaintext"><code>server {
 server_name &lt;hostname&gt;;
 listen 80;

 root &lt;document root&gt;;

 dav_methods PUT DELETE MKCOL COPY MOVE;
 dav_access group:rw all:r;
 create_full_put_path on;

 include /etc/nginx/fastcgi_params;
 fastcgi_param SCRIPT_FILENAME /var/www/webdav-extensions.php;
 fastcgi_param DEPTH $http_depth;

 location / {
 if ($request_method ~ ^(PROPFIND|OPTIONS)$) {
 fastcgi_pass localhost:9000;
 break;
 }
 }
 }
</code></pre> <p>The document root (and everything in it!) was chowned &ldquo;www-data:www-data&rdquo;, which is the user that NGINX runs as. Make sure the directory <em>above</em> your document root is owned by root, so that people using WebDAV aren&rsquo;t allowed to mess with the document root itself.</p> <p>You will note that we&rsquo;re running a PHP FCGI process (which we spawn with the LightTPD-supplied &ldquo;spawn-fcgi&rdquo; program) on localhost, on port 9000. Make sure you firewall whatever port you run your FCGI process on, or else you&rsquo;ll have a great, big security hole in your network.</p> <p>Also bear in mind that you can&rsquo;t use a vanilla Debian NGINX (or, whatever UNIX flavor you prefer), as it doesn&rsquo;t support WebDAV out-of-the-box. You will need to custom compile it with the &ldquo;&ndash;with-http<em>dav</em>module&rdquo; flag passed to &ldquo;./configure&rdquo;. It&rsquo;s not complicated, but compiling NGINX is beyond the scope of this article.</p> <p>I tested it with a <a href="http://www.webdav.org/cadaver/">UNIX client I had handy</a>, and things worked pretty well. I could look around the directories, put and retrieve files, move things around, etc. Success!</p> <p>&hellip;well, not quite. I then tried firing up a Windows client. I could put and get files just fine, but it would error out when I tried to do anything relating to directories. Spending an hour or so poking around in the NGINX access logs and the NGINX WebDAV module&rsquo;s source code and I came to realize that the Windows WebDAV client didn&rsquo;t follow the HTTP spec: when specifying a directory in HTTP, you must follow it with a slash (e.g. &ldquo;http://example.com/directory/&rdquo;, and not &ldquo;http://example.com/directory&rdquo;). Web browsers automatically account for these errors, which is why we never think about this sort of thing. However, NGINX&rsquo;s WebDAV support requires the HTTP-compliant behavior (trailing slashes and all), and thus rejects the request. This is mostly easy to fix in NGINX:</p> <pre class="highlight plaintext"><code>server {
 # ...

 location / {
 # ...

 if (-d $request_filename) { rewrite ^(.*[^/])$ $1/ break; }
 if ($request_method = MKCOL) { rewrite ^(.*[^/])$ $1/ break; }
 }
 }
</code></pre> <p>This says that if the file exists and is a directory, add a trailing slash to the request if it doesn&rsquo;t already exist. We do similarly for MKCOL (that is, create directory) requests, since we can&rsquo;t check for the directory (since we havn&rsquo;t created it yet!).</p> <p>This solved the problem of creating and deleting directories in Windows! But there was still another problem lurking beneath the surface: the COPY and MOVE methods. See, it was the same problem as above (a lack of a trailing slash), but the destination of the COPY or MOVE is specified in the HTTP &ldquo;Destination&rdquo; header. While we can retrieve headers in NGINX (since they are made available in variables, such as &ldquo;$http_destination&rdquo;), NGINX provides no way to modify them.</p> <p>I first attemped to mangle the headers in NGINX and use a proxy request to NGINX itself to solve this problem. Predictably, I was unable to do so, and even if I had succeeded, the fix would have been positively maddening. So, I took the easy way out and added support for the COPY and MOVE methods into my PHP script, leaving NGINX to handle only PUT, DELETE, and MKCOL (in addition to the raw GET, HEAD, etc. methods). Again, simple, but tedious. Once I implemented it and got it tested, though, it worked perfectly on all platforms I tested it on.</p> <p>Performance looks great, but that doesn&rsquo;t surprise me, considering that the IO-heavy methods (GET and PUT) are implemented in NGINX. The methods I support (OPTIONS, PROPFIND, COPY, and MOVE) are all very simple and transient, meaning that when we do have to drop to PHP, we don&rsquo;t have to do so for very long.</p> <p>The final NGINX setup (which included HTTP Basic Authentication and SSL, for security), looked like this:</p> <pre class="highlight plaintext"><code>server {
 server_name &lt;hostname&gt;;
 listen 443;

 root &lt;document root&gt;;

 ssl on;
 ssl_certificate &lt;ssl certificate&gt;;
 ssl_certificate_key &lt;ssl private key&gt;;

 auth_basic &lt;authentication realm&gt;;
 auth_basic_user_file &lt;password file&gt;;

 dav_methods PUT DELETE MKCOL;
 dav_access group:rw all:r;
 create_full_put_path on;

 autoindex on;
 autoindex_exact_size off;

 # Variables necessary for proper execution of the PHP script used below.
 include /etc/nginx/fastcgi_params;
 fastcgi_param SCRIPT_FILENAME /var/www/webdav-extensions.php;
 fastcgi_param DEPTH $http_depth;
 fastcgi_param HOST $host;
 fastcgi_param DESTINATION $http_destination;
 fastcgi_param OVERWRITE $http_overwrite;

 location / {
 # NGINX WebDAV support is incomplete and somewhat too strict. We handle
 # a few WebDAV methods manually in a PHP script to fill out the cracks.
 if ($request_method ~ ^(PROPFIND|OPTIONS|COPY|MOVE)$) {
 fastcgi_pass localhost:9000;
 break;
 }

 # NGINX WebDAV requires trailing slashes on directories, yet certain
 # common WebDAV clients don't support them. Do rewrites to fix it,
 if (-d $request_filename) { rewrite ^(.*[^/])$ $1/ break; }
 if ($request_method = MKCOL) { rewrite ^(.*[^/])$ $1/ break; }
 }
 }
</code></pre> <p>The final PHP script is <a href="http://files.agoragames.com/jason/webdav-extensions.php.txt">here</a>. (It&rsquo;s not 100% WebDAV complient. Or even close. But it seems to cover all the common cases, as we havn&rsquo;t had any trouble with it yet.)</p> <p>What&rsquo;s especially awesome is that, if you just want quick read-only access, you can hit the WebDAV URL in a web browser and surf around that way (thanks to the NGINX &ldquo;autoindex&rdquo; module). You can also mount this (in just about any OS, including the built-in Mac OS X, Windows, and Ubuntu clients) for drag-and-drop access to the share, just like it was a local disk.</p> <p>I have some vague notions to extend it to handle SVN and GIT (as we currently proxy to Apache for HTTP access to those). Seeing as how the logic is so simple, it would probably be trivial to patch the NGINX WebDAV module with these changes as well. Those are blog posts for another day, though.</p> </div> </div> <div class='columns large-3'> <div class=blog-archives-sidebar> <h2>Blog archives</h2> <h3> <a href="/blog/2015/">2015</a> </h3> <ul> <li> <a href="/blog/2015/10/">October 2015</a> </li> <li> <a href="/blog/2015/03/">March 2015</a> </li> <li> <a href="/blog/2015/01/">January 2015</a> </li> </ul> <h3> <a href="/blog/2014/">2014</a> </h3> <ul> <li> <a href="/blog/2014/12/">December 2014</a> </li> <li> <a href="/blog/2014/11/">November 2014</a> </li> <li> <a href="/blog/2014/10/">October 2014</a> </li> <li> <a href="/blog/2014/08/">August 2014</a> </li> <li> <a href="/blog/2014/07/">July 2014</a> </li> <li> <a href="/blog/2014/06/">June 2014</a> </li> <li> <a href="/blog/2014/04/">April 2014</a> </li> <li> <a href="/blog/2014/03/">March 2014</a> </li> <li> <a href="/blog/2014/02/">February 2014</a> </li> <li> <a href="/blog/2014/01/">January 2014</a> </li> </ul> <h3> <a href="/blog/2013/">2013</a> </h3> <ul> <li> <a href="/blog/2013/11/">November 2013</a> </li> <li> <a href="/blog/2013/10/">October 2013</a> </li> <li> <a href="/blog/2013/09/">September 2013</a> </li> <li> <a href="/blog/2013/08/">August 2013</a> </li> <li> <a href="/blog/2013/07/">July 2013</a> </li> <li> <a href="/blog/2013/06/">June 2013</a> </li> <li> <a href="/blog/2013/05/">May 2013</a> </li> <li> <a href="/blog/2013/04/">April 2013</a> </li> <li> <a href="/blog/2013/03/">March 2013</a> </li> <li> <a href="/blog/2013/02/">February 2013</a> </li> <li> <a href="/blog/2013/01/">January 2013</a> </li> </ul> <h3> <a href="/blog/2012/">2012</a> </h3> <ul> <li> <a href="/blog/2012/12/">December 2012</a> </li> <li> <a href="/blog/2012/11/">November 2012</a> </li> <li> <a href="/blog/2012/10/">October 2012</a> </li> <li> <a href="/blog/2012/09/">September 2012</a> </li> <li> <a href="/blog/2012/08/">August 2012</a> </li> <li> <a href="/blog/2012/07/">July 2012</a> </li> <li> <a href="/blog/2012/06/">June 2012</a> </li> <li> <a href="/blog/2012/05/">May 2012</a> </li> <li> <a href="/blog/2012/04/">April 2012</a> </li> <li> <a href="/blog/2012/03/">March 2012</a> </li> <li> <a href="/blog/2012/02/">February 2012</a> </li> <li> <a href="/blog/2012/01/">January 2012</a> </li> </ul> <h3> <a href="/blog/2011/">2011</a> </h3> <ul> <li> <a href="/blog/2011/10/">October 2011</a> </li> <li> <a href="/blog/2011/09/">September 2011</a> </li> <li> <a href="/blog/2011/08/">August 2011</a> </li> <li> <a href="/blog/2011/07/">July 2011</a> </li> <li> <a href="/blog/2011/06/">June 2011</a> </li> <li> <a href="/blog/2011/05/">May 2011</a> </li> <li> <a href="/blog/2011/04/">April 2011</a> </li> <li> <a href="/blog/2011/03/">March 2011</a> </li> <li> <a href="/blog/2011/02/">February 2011</a> </li> <li> <a href="/blog/2011/01/">January 2011</a> </li> </ul> <h3> <a href="/blog/2010/">2010</a> </h3> <ul> <li> <a href="/blog/2010/12/">December 2010</a> </li> <li> <a href="/blog/2010/11/">November 2010</a> </li> <li> <a href="/blog/2010/10/">October 2010</a> </li> <li> <a href="/blog/2010/09/">September 2010</a> </li> <li> <a href="/blog/2010/08/">August 2010</a> </li> <li> <a href="/blog/2010/07/">July 2010</a> </li> <li> <a href="/blog/2010/06/">June 2010</a> </li> <li> <a href="/blog/2010/05/">May 2010</a> </li> <li> <a href="/blog/2010/04/">April 2010</a> </li> <li> <a href="/blog/2010/03/">March 2010</a> </li> <li> <a href="/blog/2010/02/">February 2010</a> </li> <li> <a href="/blog/2010/01/">January 2010</a> </li> </ul> <h3> <a href="/blog/2009/">2009</a> </h3> <ul> <li> <a href="/blog/2009/12/">December 2009</a> </li> <li> <a href="/blog/2009/11/">November 2009</a> </li> <li> <a href="/blog/2009/10/">October 2009</a> </li> <li> <a href="/blog/2009/09/">September 2009</a> </li> <li> <a href="/blog/2009/08/">August 2009</a> </li> <li> <a href="/blog/2009/07/">July 2009</a> </li> <li> <a href="/blog/2009/06/">June 2009</a> </li> <li> <a href="/blog/2009/05/">May 2009</a> </li> <li> <a href="/blog/2009/04/">April 2009</a> </li> <li> <a href="/blog/2009/03/">March 2009</a> </li> <li> <a href="/blog/2009/02/">February 2009</a> </li> <li> <a href="/blog/2009/01/">January 2009</a> </li> </ul> <h3> <a href="/blog/2008/">2008</a> </h3> <ul> <li> <a href="/blog/2008/11/">November 2008</a> </li> <li> <a href="/blog/2008/10/">October 2008</a> </li> <li> <a href="/blog/2008/09/">September 2008</a> </li> <li> <a href="/blog/2008/08/">August 2008</a> </li> </ul> </div> </div> </div> <script src="/assets/javascripts/app-8d34dc05.js" async=true></script> </body> </html>